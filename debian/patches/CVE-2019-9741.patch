Origin: https://github.com/golang/go/commit/829c5df58694b3345cb5ea41206783c8ccf5c3ca
Origin: https://github.com/golang/go/commit/f1d662f34788f4a5f087581d0951cdf4e0f6e708
Reviewed-by: Chris Lamb <lamby@debian.org>
Reviewed-by: Sylvain Beucler <beuc@debian.org>
Last-Update: 2021-02-25

Index: golang-1.3.3/src/pkg/net/http/request.go
===================================================================
--- golang-1.3.3.orig/src/pkg/net/http/request.go
+++ golang-1.3.3/src/pkg/net/http/request.go
@@ -378,7 +378,12 @@ func (req *Request) write(w io.Writer, u
 		// CONNECT requests normally give just the host and port, not a full URL.
 		ruri = host
 	}
-	// TODO(bradfitz): escape at least newlines in ruri?
+	if stringContainsCTLByte(ruri) {
+		return errors.New("net/http: can't write control character in Request.URL")
+	}
+	// TODO: validate r.Method too? At least it's less likely to
+	// come from an attacker (more likely to be a constant in
+	// code).
 
 	// Wrap the writer in a bufio Writer if it's not already buffered.
 	// Don't always call NewWriter, as that forces a bytes.Buffer
@@ -873,3 +878,14 @@ func (r *Request) closeBody() {
 		r.Body.Close()
 	}
 }
+
+// stringContainsCTLByte reports whether s contains any ASCII control character.
+func stringContainsCTLByte(s string) bool {
+	for i := 0; i < len(s); i++ {
+		b := s[i]
+		if b < ' ' || b == 0x7f {
+			return true
+		}
+	}
+	return false
+}
Index: golang-1.3.3/src/pkg/net/url/url.go
===================================================================
--- golang-1.3.3.orig/src/pkg/net/url/url.go
+++ golang-1.3.3/src/pkg/net/url/url.go
@@ -361,6 +361,10 @@ func ParseRequestURI(rawurl string) (url
 func parse(rawurl string, viaRequest bool) (url *URL, err error) {
 	var rest string
 
+	if stringContainsCTLByte(rawurl) {
+		return nil, errors.New("net/url: invalid control character in URL")
+	}
+
 	if rawurl == "" && viaRequest {
 		err = errors.New("empty url")
 		goto Error
@@ -698,3 +702,14 @@ func (u *URL) RequestURI() string {
 	}
 	return result
 }
+
+// stringContainsCTLByte reports whether s contains any ASCII control character.
+func stringContainsCTLByte(s string) bool {
+	for i := 0; i < len(s); i++ {
+		b := s[i]
+		if b < ' ' || b == 0x7f {
+			return true
+		}
+	}
+	return false
+}
Index: golang-1.3.3/src/pkg/net/url/url_test.go
===================================================================
--- golang-1.3.3.orig/src/pkg/net/url/url_test.go
+++ golang-1.3.3/src/pkg/net/url/url_test.go
@@ -903,3 +903,23 @@ func TestParseFailure(t *testing.T) {
 		t.Errorf(`ParseQuery(%q) returned error %q, want something containing %q"`, url, errStr, "%gh")
 	}
 }
+
+func TestRejectControlCharacters(t *testing.T) {
+	tests := []string{
+		"http://foo.com/?foo\nbar",
+		"http\r://foo.com/",
+	"http://foo\x7f.com/",
+	}
+	for _, s := range tests {
+		_, err := Parse(s)
+		const wantSub = "net/url: invalid control character in URL"
+		if got := fmt.Sprint(err); !strings.Contains(got, wantSub) {
+			t.Errorf("Parse(%q) error = %q; want substring %q", s, got, wantSub)
+		}
+	}
+
+	// But don't reject non-ASCII CTLs, at least for now:
+	if _, err := Parse("http://foo.com/ctl\x80"); err != nil {
+		t.Errorf("error parsing URL with non-ASCII control byte: %v", err)
+	}
+}
Index: golang-1.3.3/src/pkg/net/http/fs_test.go
===================================================================
--- golang-1.3.3.orig/src/pkg/net/http/fs_test.go
+++ golang-1.3.3/src/pkg/net/http/fs_test.go
@@ -5,6 +5,7 @@
 package http_test
 
 import (
+	"bufio"
 	"bytes"
 	"errors"
 	"fmt"
@@ -470,16 +471,23 @@ func TestFileServerZeroByte(t *testing.T
 	ts := httptest.NewServer(FileServer(Dir(".")))
 	defer ts.Close()
 
-	res, err := Get(ts.URL + "/..\x00")
+	c, err := net.Dial("tcp", ts.Listener.Addr().String())
 	if err != nil {
 		t.Fatal(err)
 	}
-	b, err := ioutil.ReadAll(res.Body)
+	defer c.Close()
+	_, err = fmt.Fprintf(c, "GET /..\x00 HTTP/1.0\r\n\r\n")
 	if err != nil {
-		t.Fatal("reading Body:", err)
+		t.Fatal(err)
+	}
+	var got bytes.Buffer
+	bufr := bufio.NewReader(io.TeeReader(c, &got))
+	res, err := ReadResponse(bufr, nil)
+	if err != nil {
+		t.Fatal("ReadResponse: ", err)
 	}
 	if res.StatusCode == 200 {
-		t.Errorf("got status 200; want an error. Body is:\n%s", string(b))
+		t.Errorf("got status 200; want an error. Body is:\n%s", got.Bytes())
 	}
 }
 
Index: golang-1.3.3/src/pkg/net/http/requestwrite_test.go
===================================================================
--- golang-1.3.3.orig/src/pkg/net/http/requestwrite_test.go
+++ golang-1.3.3/src/pkg/net/http/requestwrite_test.go
@@ -455,6 +455,18 @@ var reqWriteTests = []reqWriteTest{
 			"ALL-CAPS: x\r\n" +
 			"\r\n",
 	},
+
+	{
+		Req: Request{
+			Method: "GET",
+			URL: &url.URL{
+				Host:     "www.example.com",
+				RawQuery: "new\nline", // or any CTL
+			},
+		},
+
+		WantError: errors.New("net/http: can't write control character in Request.URL"),
+	},
 }
 
 func TestRequestWrite(t *testing.T) {
