https://github.com/golang/go/commit/829c5df58694b3345cb5ea41206783c8ccf5c3ca
https://github.com/golang/go/commit/f1d662f34788f4a5f087581d0951cdf4e0f6e708

--- golang-1.3.3.orig/src/pkg/net/http/request.go
+++ golang-1.3.3/src/pkg/net/http/request.go
@@ -378,7 +378,12 @@ func (req *Request) write(w io.Writer, u
 		// CONNECT requests normally give just the host and port, not a full URL.
 		ruri = host
 	}
-	// TODO(bradfitz): escape at least newlines in ruri?
+	if stringContainsCTLByte(ruri) {
+		return errors.New("net/http: can't write control character in Request.URL")
+	}
+	// TODO: validate r.Method too? At least it's less likely to
+	// come from an attacker (more likely to be a constant in
+	// code).
 
 	// Wrap the writer in a bufio Writer if it's not already buffered.
 	// Don't always call NewWriter, as that forces a bytes.Buffer
@@ -873,3 +878,14 @@ func (r *Request) closeBody() {
 		r.Body.Close()
 	}
 }
+
+// stringContainsCTLByte reports whether s contains any ASCII control character.
+func stringContainsCTLByte(s string) bool {
+	for i := 0; i < len(s); i++ {
+		b := s[i]
+		if b < ' ' || b == 0x7f {
+			return true
+		}
+	}
+	return false
+}
--- golang-1.3.3.orig/src/pkg/net/url/url.go
+++ golang-1.3.3/src/pkg/net/url/url.go
@@ -361,6 +361,10 @@ func ParseRequestURI(rawurl string) (url
 func parse(rawurl string, viaRequest bool) (url *URL, err error) {
 	var rest string
 
+	if stringContainsCTLByte(rawurl) {
+		return nil, errors.New("net/url: invalid control character in URL")
+	}
+
 	if rawurl == "" && viaRequest {
 		err = errors.New("empty url")
 		goto Error
@@ -698,3 +702,14 @@ func (u *URL) RequestURI() string {
 	}
 	return result
 }
+
+// stringContainsCTLByte reports whether s contains any ASCII control character.
+func stringContainsCTLByte(s string) bool {
+	for i := 0; i < len(s); i++ {
+		b := s[i]
+		if b < ' ' || b == 0x7f {
+			return true
+		}
+	}
+	return false
+}
